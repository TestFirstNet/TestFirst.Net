<?xml version="1.0"?>
<package>
  <metadata>
    <id>$id$</id>
    <version>$version$</version>
    <title>$title$</title>
    <authors>TestFirst.Net</authors>
    <owners>TestFirst.Net</owners>
    <licenseUrl>http://testfirstnet.github.io/TestFirst.Net/LICENSE.txt</licenseUrl>
    <projectUrl>https://github.com/TestFirstNet/TestFirst.Net/</projectUrl>
    <iconUrl>http://testfirstnet.github.io/TestFirst.Net/icon.png</iconUrl>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <description>Testing library providing a fluent tdd/bdd testing approach. Can be easily integrated into your own testing tools (nunit, xunit, moq, etc)</description>
	<description>

1. Summary

	Testing library providing a fluent tdd/bdd testing approach. Can be easily integrated 
	into your own testing tools (nunit, xunit, moq, etc)

	The idea is to try:
			
		a) Understandable
			i) tests should be easy to understand. Tests are read far more often than they are written. Focus on the read part
			ii) if possible make tests easy to write too. Easy to write tests result in more test code and more fun
			iii) keep tests as close to natural language as possible as this is quicker to parse, though try to eliminate ambiguity
		b) Make the IDE work for you
			i) support autocomplete
			ii) support refactoring
			iii) make it easy to jump directly to code doing the actual work
		c) Integration		
			i) easy integration with existing test infrastructure
		d) Extensibility 		
			i) make it easy to extend and customise your tests.
			ii) test infrastructure should aid you not hinder
			iii) allow you to do your own thing when required
		e) Discoverability
			i) make auto discovery of things easy without the need to go read the documentation. 
			ii) a consistent and easy to guess naming pattern.
		f) Diagnostics
			i) If a test fails tell me why and give me as much info as possible why it failed. Don't tell me foo is wrong, 
			   tell me why and what was expected and what was actually found, and any other related info
		g) DRY - Don't repeat yourself yourself
			i) Don't repeat the same boring string assertion, or complex relationship tests across all your tests. Put it 
			   in a single place (your Matcher)

	For example, the scenario:

		"Given a registered user, with an account balance of 10 dollars, when 6 dollars is debited, then 
		expect that the account only has 4 dollars, and the transaction ledger records a 6 dollar debit"

	can be written in TestFirst.Net as:

		Scenario()
			.Given(user = UserInTheDb().WithDefaults())
			.Given(account=AccountInTheDb().For(user).Balance(10).Dollars())
			
			.When(()=>account.debit(6))

			.Then(
				ExpectThat(TheAccountInTheDb.For(account)),
				Is(AnAcccount.With().Balance(4).Dollars())
			.Then(
				ExpectThat(TheAccountLedgerInTheDb.For(account)),
				Is(AnLedger.With().Debit(6).Dollars());
		
	Which depending on the number of beers you've drunk resembles the natural english version fairly closely without the need of an additional
	template translation step in the process (so refactoring won't kill things, find references still work, can step directly to the assertion code)	

2. Matchers

	The whole of TestFirst.Net centers around the concept of a 'Matcher'. This is an object separate from your individual unit test to perform assertions
	on the objects and services under test. Naming convention is that matcher names start with an 'A' or an 'An'

	Examples:

		AString.Contains(...)

		AFoo.With().Bar("123").Fibble(AFibble.With().BigEars().NoMoustache());

	The idea is that as you flesh out your tests over time, more and more of the test code can be reused. This is
	versus all the assertions repeated in your test. So for example if there is a concept of a 'valid' email address, 
	there can be an email address matcher, or in combination with your user matcher you can call:

		AUser.With().ValidEmail() under the hood might call 'AnEmailAddress.IsValid(...)'

	Ditto for a valid user account, trade etc

	As more and more matchers are added over time, more of your tests can be written using existing matchers.
	
	Remember, auto complete is your friend! If you stick to the naming conventions, you only need to start typing 
	and in theory completions should come up. 

	The static create method is usually 'With' for complex matchers, or simply the matcher method for simpler 
	ones. Sometimes 'Of' or 'For' are used if this aids in the fluent langauge

    There are basic matchers for mst of the primitive types, along for other base types. Simply hit 'A' and start typing. 
	Some existing ones are 'AString', 'AnInt', 'ADecimal', 'ADateTime', 'AList','ADictionary', 'AnInstance'. Others are 
	for you to write for your own objects. The neat thing is this can then be reused across tests. 

	There is a code generator to generate matchers automatically for each of your objects.

3. Usage

	3.1 Using just the assertions

	This is useful if you only want to make use of the matchers and/or sprinkle your existing tests with a bit of TestFirst.Net

	Examples:

		...do stuff in your test
	
	    Expect
			.That(foolist) //&lt;--thing we want to assert
			.Is(AList.InAnyOrder().WithOnly("a").And("b")); //&lt;--'Matcher' we are using to perform the assertion
    
		Expect
			.That(()=>foo.DoIt())
			.Throws(AnException.Of().Type&lt;MyException&gt;().Message(AString.ContainingIgnorePunctuationAndCase("Some bad thing")));
	

	3.2 Full TDD 
	
	Setup scenarios which provide injection, db creation, db insertion and retrieval, service startup, resource cleanup. 

	You can still roll it as you wish by combining or swapping out the parts yourself. This still integrates with your existing test classes

	[TestFixture]
	MyTestScenario : AbstractNUnitScenarioTest {...//or AbstractNUnitMoqScenarioTest or ScenarioFluency
	
		[Test]
		public void HappyPathUserCorrectlyRegistered(){
			RegistrationService service;
			Registration reg;			

			Scenario() &lt;-- passes back a 'Scenario' object with an injector
				.Given(reg = UserRegistration.With().Defaults().Age(123).RandomPassword()..)
				.Given(service = NewRegistrationService())	//&lt;!--this is disposed at end of test
				.When(service.register(reg))//&lt;!--interesting part of test
				.Then(
					ExpectThat(UserInTheDb.With().UserName(reg.UserName)),
					Is(AUserInTheDb.With().Age(reg.Age)...))//&lt;-- UserInTheDb is a 'finder'
				.Then(
					ExpectThat(LoginInTheDb.With().UserName(reg.UserName)),
					Is(ALoginInTheDb.With().Password(reg.Password)...))
				.Then(
					ExpectThat(AccountInTheDb.With().UserName(reg.UserName)),
					Is(AnAccount.With().Created(ADateTime.After(now)...))

		}
	}

	Test now clearly shows the setup, the operation(s) we're testing, and the expected result

	The 'XInTheDb', as in 'UserInTheDb' implements the 'IFetcher' interface. This simply is used to look things up (how you do it 
	up to you). It will also have dependencies injected

4. Objects

	4.1 Matchers (IMatcher)
		
	As mentioned previously, these are used to match results against

	4.2 Fetchers  (IFetcher)
		
	These fetch things given a set of criteria. They can be passed to a 'Then' method to find the object to assert on using 
	a given matcher. Simply implement a 'Fetch' method.

	4.3 Inserters (IInserter)
	
	These insert things. What they insert into what is up to you. They simply implement an 'Insert' method. Disabled if
	running tests against a prod database

	4.4 Updaters (IUpdater)

	Perform cleanup,delete or update stuff. Implements, you guessed it, 'Update'.

	4.5 Invokers (IInvokable)

	Do something when passed to 'Given','When','Then'. Implements 'Invoke'

	4.6 Builders (IBuilder)

	Anything passed to 'Given','When','Then' which is a builder will have it's 'Build' method called. This allows for building
	up complex test state in an easy to read way. Builders also have depedencies injected.
	
	4.7 Dependency injector (IStepArgDependencyInjector)

	All the objects passed to Given, When, Then are passed through this injector to have dependencies set. The default setup simply
	collects all objects implementing 'IDisposable' and disposes of them in reverse order.

	</description>
    <releaseNotes>
    Noteable changes
      * Updated : Various bug fixes
      * Updated : AList now better supports mixed lists
      * Updated : Improved diagnostic error messages
      * Updated : Addition of new match methods on various matchers 
      * New : Add new matchers AnException,AChar
      * New : Add Expect.That(..).Throws(..) for exception testing
    </releaseNotes>
    <copyright>Copyright Â© TestFirst.Net 2014 - 2015</copyright>
    <tags>testing tdd bdd fluent nunit moq</tags>
  </metadata>
  <!-- don't include /content/ in nupkg -->
  <files />
</package>
